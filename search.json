[{"title":"SpringBoot-chapter14","url":"/2023/03/17/SpringBoot/SpringBoot-chapter14/","content":"# SpringBoot整合RabbitMQ消息中间件\n<!-- more -->\nRabbitMQ是实现了高级消息队列协议（AMQP)(advanced massage queuing protocol)的消息中间件，通过它可以在模块间构建可靠的消息传输队列，以实现模块间的有效交互。\nRabbitMQ是用Erlang语言开发的消息中间件，可以实现解耦模块间复杂业务逻辑和高并发缓存等高级业务功能\n## 消息队列和RabbitMQ消息中间件\n消息队列是消息中间件的内部队列，可以用来存储消息。而消息中间件是和业务无关的，用来存储和传递消息的第三方组件，在消息中间件中，除了会有消息队列以外，还会封装针对消息以及消息队列的操作方法，比如发送消息，订阅消息和持久化消息\n\n{% asset_img 图14-1.png %}\n\n## 消息交换机与消息队列\n\n一个RabbitMQ消息中间件中可以有多个消息对列，分别用来存储不同主题的消息\n{% asset_img 图14-2.png %}\n## SpringBoot整合RabbitMQ\n\n{% asset_img 图14-3.png %}\n\n## 用RabbitMQ搭建异步交互系统\n由于RabbitMQ消息中间件能在模块间传递消息，因此项目中的诸多业务模块可以用该组件搭建异步交互系统。引入异步交互机制的目的不仅是为了进一步解耦诸多业务模块，更是为了能够在高并发场景中提升相关业务模块的运行性能。\n{% asset_img 图14-4.png %}\n\n### 观察异步交互流程\n{% asset_img 图14-5.png %}\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter13","url":"/2023/03/17/SpringBoot/SpringBoot-chapter13/","content":"# SpringBoot整合Dubbo和Zookeeper\n<!-- more -->\n## 远端方法调用和Dubbo组件\nDubbo是阿里巴巴开发的一款高性能的JavaRPC（Remote Procedure Call，远程方法调用），Dubbo定义的方法可以被同一主机或者不同主机的其他模块调用，一般会用应用协调组件Zookeeper来作为Dubbo的注册中心。远端方法先是到Zookeeper注册中心获取方法列表和参数，再以RPC的方式进行远端调用。\n{% asset_img 图13-1.png %}\n## Dubbo注册中心与Zookeeper组件\n{% asset_img 图13-2.png %}\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter12","url":"/2023/03/05/SpringBoot/SpringBoot-chapter12/","content":"# SpringBoot整合MyCAT分库组件\n<!-- more -->\n**关键词：大表，分库规则，子表**\n## 分库需求与MyCAT组件\n{% asset_img 图12-1.png %}\n{% asset_img 图12-2.png %}\n\n## SpringBoot整合Redis与MyCAT组件  \n- 目的：\n  - 降低大表规模\n  - 缓存数据\n  - 提高数据库访问性能\n  \n{% asset_img 图12-3.png %}","tags":["SpringBoot"]},{"title":"SpringBoot-chapter11","url":"/2023/02/26/SpringBoot/SpringBoot-chapter11/","content":"# SpringBoot整合Redis缓存\n<!-- more -->\n## 了解redis\nRedis是一种用键值对格式存储数据的NoSQL数据库，由于Redis数据库是在内存中缓存数据的，因此他的读写性能很高  \n**优点:**\n1. 读写数据的性能较高\n2. 支持多种数据类型\n3. 支持数据持久化  \n\n**缺点**  \n1. 较难支持扩容操作\n2. 数据过多时造成内存问题\n3. 基于单线程操作，持久化等操作时会阻塞工作线程\n## Redis常用命令\n### set和get\nset key value [ex seconds][PX milliseconds] [NX|XX]  \n``` \nset student_001 perter EX 3600\nget student_001\n```\n### del命令\n```\ndel student_001\n```\n### exits命令\n判断指定的键是否存在\n```\nexists student_001\n```\n## Redis基本数据类型\n### 字符串类型\nmset和mget命令同时设置和读取多个字符串类型的数据\n```\nmset key value [key velue...]\nmget key [key...]\n```\n### Hash类型\nRedis中通过Hash类型的变量来缓存对象数据\n```\nhset key field value\nhget key field\n```\n### 列表类型\n在Redis中，可以用列表的形式在一个健中存储一个或多个数据。具体可以通过lpush命令把一个和多个值依次插入列表的头部  \n通过index命令可以读取列表格式的值，其中通过key参数能指定待读取的列表，通过index能指定待读取列表值的索引号，从0开始##\n```\nlpush key element [element...]\nlindex key index\n```\n### 集合类型\n和列表相似，但是不能重复\n```\nsadd key member [member ...]\nsmember key\n```\n### 有序集合类型\n和集合相似，不过在有序集合中，每个元素都会对应一个score参数，依此来描述该数据在有序集合中的分数，并且该分数是有序集合中排序的基础\nNX参数表示只有当key对应的有序集合不存在时才能添加元素，而XX参数表示当有序集合存在时才能添加元素\n通过zrange命令能读取指定key中score区间范围内的数据，其中start和stop表示最低和最高的score，如果带WITHSCORES参数，则会同时显示元素所对应的score值\n```\nzadd key [NX}XX] [CH] [INCR] score member [score member ...]\nzrange key start stop [WITHSCORES]\n```\n## SpringBoot整合数据库与Redis缓存\n在数据库整合Redis缓存时，应用程序会先从Redis服务器中读取数据，如果读到则直接使用，否则访问数据库，同时把从数据库中读到的数据放入缓存\n在删除数据时，会在删除数据库中数据的同时删除缓存中的数据，更新时，首先删除缓存数据，在更新数据库数据\n{% asset_img 图11-1.png %}\n### 防缓存穿透的设计\n如果在高并发的场景中，大量的查询请求会“穿透Redis缓存”，如果并发量超过了数据库的负载，数据库就会无法继续接受请求，从而造成严重的产线问题。\n防穿透的做法是，缓存null值和数据库不存在的健，这些请求会被Redis挡住，就不会再到数据库中查询一遍。\n### 防内存溢出的设计\n如果不设置超时时间，每次的缓存数据就会一直保存在内存中，时间长了，就会导致内存溢出问题。\n可以在缓存数据时为每个数据设置一个合理的超时时间。\n采用整数加随机数的方式，从而在避免内存溢出的同时，也能避免缓存穿透问题\n\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter10","url":"/2023/02/25/SpringBoot/SpringBoot-chapter10/","content":"# SpringBoot整合MongoDB\n<!-- more -->\nMongoDB是一种基于分布式文件存储的数据库\n优点：  \n- 以文档的方式存储数据，语法简单\n- 支持分布式文档存储，具有较高的扩展性\n- 应用在大数据场景中，读写数据的性能较高  \n\n缺点：  \n- 不支持事务，很少应用在多并发场景中\n- 会占用大量的磁盘空间\n- 缺乏成熟的维护工具\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter9","url":"/2023/02/25/SpringBoot/SpringBoot-chapter9/","content":"# SpringBoot整合安全管理框架\n<!-- more -->\n## 安全管理与Spring Security框架\n安全管理方面的需求一般可以归纳成“身份验证”和认证授权“\n## SpringBoot 整合Spring Security\n1. 身份验证\n2. 获取当前用户的授权信息，并开放对应的Spring Boot服务\n3. 通过数据库以持久化的方式保存用户的信息，并以crud的方式动态管理身份及授权信息\n4. 实现基于role的授权管理方式\n## SpringBoot整合Shiro框架\n\n","tags":["SpringBoot"]},{"title":"计算机系统概述","url":"/2023/02/15/操作系统/01_计算机系统概述/","content":"# 操作系统的基本概念\n## 概念\n## 特征\n- 并发\n- 共享\n- 虚拟\n- 异步\n<!-- more -->\n## 目标和功能\n1. 资源管理者\n- 处理机管理\n- 存储器管理\n- 文件管理\n- 设备管理\n2. 系统接口\n- 命令接口\n- 程序接口\n3. 对计算机资源的扩充\n# 操作系统发展历程\n1. 手工阶段\n2. 批处理阶段\n- 单批道处理系统\n- 多批道处理系统\n3. 分时操作系统\n4. 实时操作系统\n5. 网络操作系统和分布式计算机系统\n6. 个人计算机操作系统\n# 操作系统运行环境\n## 处理器运行模式\n- 特权指令\n- 非特权指令  \n### 操作系统内核\n1. 时钟管理\n2. 中断机制\n3. 原语\n4. 系统控制的数据结构及处理\n## 中断和异常的概念\n1. 中断和异常的定义\n2. 中断和异常的分类\n3. 中断和异常的处理过程\n## 系统调用\n1. 设备管理\n2. 文件管理\n3. 进程控制\n4. 进程通信\n5. 内存管理\n# 操作系统结构\n1. 分层法\n2. 模块化\n3. 宏内核\n4. 微内核\n- 微内核的基本概念\n- 微内核的基本功能\n  - 进程（线程）管理\n  - 低级存储器管理\n  - 中断和陷入处理\n- 微内核的特点\n  - 扩展性和灵活\n  - 可靠性和安全性\n  - 可移植性\n  - 分布式计算\n- 外核\n# 操作系统引导\n1. 激活cpu\n2. 硬件自检\n3. 加载带有操作系统的硬盘\n4. 加载主引导记录MBR\n5. 扫描硬盘分区表\n6. 加载分区引导记录PBR\n7. 加载启动管理器\n8. 加载操作系统\n# 虚拟机\n## 概念\n1. 第一类虚拟机管理程序\n2. 第二类虚拟机管理程序\n\n\n\n","tags":["操作系统"]},{"title":"Git","url":"/2023/02/12/Git/Git/","content":"# Git\n能够记录文件修改历史的版本管理系统  \n界面管理软件SourceTree\n<!-- more -->\n1. 创建仓库\n2. 提交\n- 想从暂存区域撤回的时候怎么办\n- 为什么提交一定要有注释\n3. 用checkout移动提交\n4. 复制仓库（fork）\n5. 创建分支\n6. 合并分支\n7. 推送\n8. 拉取\n9. 解决冲突\n10. 从拉取请求到合并\n11. 忽略无需进行版本管理的文件\n- 分支的运用规则\n12. 回到过去、创建新分支、修改内容\n13. 撤销过去的提交（revert）\n14. 提交历史合并为一条直线（rebase）\n15. 合并多个提交（squash）\n16. 拉取是怎样实现的\n17. 获取远程仓库最新的状态（fetch)\n18. 删除不需要的远程分支\n19. 修改最近的提交注释\n20. 暂存未提交的内容（stash）\n21. 从其他分支上获取特定提交（cherry-pic）\n22. 给提交上做标记\n23. 错误地把Head直接指向了某次提交\n","tags":["Git"]},{"title":"SpringBoot-chapter8","url":"/2023/02/10/SpringBoot/SpringBoot-chapter8/","content":"# SpringBoot整合Junit单元测试组件\n<!-- more -->\n单元测试是指对每个业务单元的功能进行验证测试，在此指一个类\n## Junit组件简介\n1. asertEquals和asertTrue，都能对比待测试方法的实际返回值和预期值。但assertEquals在运行失败是会输出预期值和返回值，所以更常用\n2. asserNUll\n3. assetTrows\n4. when(语句).thenReturn（返回值）\n5. when(语句).thenTrows(异常类)\n## 其他测试\n- 集成测试-人为的，单元集合一起测试\n- 性能测试-压力测试，Jmeter发起高并发请求\n- 自动化测试-编写脚本，使用工具","tags":["SpringBoot"]},{"title":"SpringBoot-chapter7","url":"/2023/02/10/SpringBoot/SpringBoot-chapter7/","content":"# SpringBoot 整合日志组件\n<!-- more -->\nSpring Boot整合logback输出日志  \nlogback—sping.xml 配置文件  \n输出日志顺序 TRACE<DEBUG<INFO<WARN<ERROR \n为每个线程设置唯一标识，方便追踪问题\n格式化日志文件名，方便排查问题\nlog_%d(yyyy-mm-dd).log 一天生成一次\n## 搭建ELK运行环境\n**ElasticSearch、Logstash、Kibana**  \n{% asset_img 图7-1.png %}\n## Spring Boot整合ELK平台\nSpring Boot向ELK输出日志  \n在Kibana中观察日志  \n项目产生的日志经过LogStash和ElasticSearch组件，最终展示在Kibana可视化界面上\n{% asset_img 图7-2.png %}\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter6","url":"/2023/02/10/SpringBoot/SpringBoot-chapter6/","content":"# 用Restful规范提供统一风格的服务\n<!-- more -->\n## url请求、http动作和返回码   \n| 动作|说明|\n|----|----|\n|Get|url请求|\n|Post|请求体|\n|Put|更新|\n|Delete|删除|\n<!-- more -->\n|返回码|说明|\n|----|----|\n|200|正确|\n|201|正确创建对象|\n|301|重定向|\n|400|服务器不理解|\n|404|页面找不到|\n|500|服务器错误，无法返回请求|\n|504|网关超时|\n\nRestful：是定义增删改查请求URl的设计规范\n## 调用不同版本\n/v1/stock  \n/v2/stock\n## 用RestTemplate调用Restful请求\n|方法名|说明|  \n|---|---|\n|getForEntity|调用Get类型请求|\n|postForObject|调用Post类型请求|\n|Put|Put类型|\n|Delete|Delete类型|\n## 用Swagger可视化Restful请求\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter5","url":"/2023/02/09/SpringBoot/SpringBoot-chapter5/","content":"# 面向切面编程与过滤器拦截器\n<!-- more -->\n## 相关概念\n- 切面是指待插入的逻辑代码\n- 切入点是指在哪个位置插入切面代码\n- 通知是指在正常代码运行到切入点的位置时，Spring容器等会通知切面代码运行\n- 常用的通知类型有：前置~，后置~，环绕~，后置成功~，后置异常~\n- 定义切入点@pointcut\n## SpringBoot与拦截器\n### 拦截器的重要方法\n- preHandle 返回true执行下个拦截器，返回false执行被拦截\n- postHandle void\n- afterCompletion void\n## SpringBoot与过滤器\n### 过滤器的重要方法\n- init\n- doFilter\n- destroy\n## 过滤器和拦截器的异同点\n1. 拦截器基于Java反射机制，过滤器基于函数回调机制\n2. 定于拦截器依赖Servlet容器，过滤器不需要\n3. 对于不同的请求拦截器可以初始化多次，过滤器只能只能在容器初始化时被执行一次\n4. 拦截器可以获取Spring容器中的Bean，过滤器不行  \n**如果只想过滤具有指定特征的URL请求或者session中不包含指定对象的请求可以使用过滤器，如果想在请求被处理前添加通用性的动作，比如打印日志或者监控内存等，可以使用拦截器。**","tags":["SpringBoot"]},{"title":"SpringBoot-chapter4","url":"/2023/02/09/SpringBoot/SpringBoot-chapter4/","content":"# Spring Boot 整合前端模板\n<!-- more -->\n## Thymeleaf模板与前后端交互\n### 前后端交互对象ModelAndView\n## 通过JPA获取对象并传给前端\n## 用Thymeleaf模板演示分页效果\n## Spring Boot整合FreeMarker\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter3","url":"/2023/02/07/SpringBoot/SpringBoot-chapter3/","content":"# Spring Boot 用JPA操作数据库\n<!-- more -->\n## 通过JpaRepository访问数据库\n引入JPA依赖包\n编写JPA配置文件\n## 用JpaRepository编写Repo类\n## 实现分页和排序的JPA接口\n用PagingAndSortingRepository实现排序和分页\n## JPA从方法名中解析数据库操作的方式\n## 用@Query查询数据\n## 用nativeQuery参数运行原生SQL语句\n## 通过JPA组件引入事务\n## 用@Transactional注解管理事务\n## 定义事务隔离级别\n脏读，不可重复读，幻读\n## 定义事务传播机制\n","tags":["SpringBoot"]},{"title":"SpringBoot-chapter2","url":"/2023/02/02/SpringBoot/SpringBoot-chapter2/","content":"# SpringBoot编程基础\n<!-- more -->\n- 控制反转 IOC\n- 依赖注入 DI\n- @SpringBootApplication 启动类\n- 热部署\n- Banner定制启动信息\n- 控制器类\n  - @RestController\n  - @RestMapping(value=\"/url\",methond=\" \",params={\" \",\" \"})\n  - 读取参数\n    - url/{参数}/{参数}-> 方法（@PathVariable 类型 名称，...)\n    - url,params={\" \",\" \"...}->方法（@RequestParam 类型 名称,...)\n- 返回JSON格式 produces={\"application/json\"}\n- 业务逻辑类 @Service\n- @Autowire 引入容器中的类\n- 配置文件\n  - .properties:参数名=参数值\n  - .yml:  \n  {  \n  db:  \n    缩进username:空root  \n    缩进password:空root  \n  }\n- 读取 @Autowired private Environment env;\n- @value(\"${...}\")","tags":["SpringBoot"]},{"title":"SpringBoot_chapter1","url":"/2023/02/01/SpringBoot/SpringBoot-chapter1/","content":"# 第一个SpringBoot项目\n<!-- more -->\nSpring Boot是以注解的方式管理项目的，比如用 **@SrpringBootApplication** 注解来指定启动类，用 **@RestController** 注解来指定控制类。这与XML文件进行配置的SSM等框架相比，大大提高了开发和管理项目的效率。\n## markdown 语法练习\nhello **word** *i* ***am*** a new person\n>yes you can call me jack\n>>wow you are beautiful\n># thank you so much\n>- i feel much better\n>* well, what to do next\n>+ i dont konw\n>1. you should think about it\n>2. you can do it\n1. how are you  \n   add two blank\n```\nprintf(\"hello word\");\n```\n***\n----\n[百度](www.baidu.com \"这是百度\")  \n<www.baidu.com>  \n","tags":["SpringBoot"]},{"title":"myfirsthexo","url":"/2023/01/31/first/myfirsthexo/","content":"### hello word\n<!-- more -->\nmore注释之前显示预览\n","tags":["first"],"categories":["first"]}]